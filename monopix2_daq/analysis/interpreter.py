import sys
import time
import os
import numpy as np
import numba
from tqdm import tqdm
import tables as tb

class_spec = [
    ('chunk_size', numba.uint32),
    
    ('monopix_data_flag', numba.uint8),
    ('monopix_token_timestamp', numba.int64),

    ('rx_timestamp640_flag', numba.uint8),
    ('rx_timestamp640', numba.int64),

    ('inj_timestamp640_flag', numba.uint8),
    ('inj_timestamp640', numba.int64),

    ('mon_timestamp640_flag', numba.uint8),
    ('mon_timestamp640', numba.int64),
    ('mon_tot640', numba.int16),

    ('tlu_timestamp640_flag', numba.uint8),
    ('tlu_timestamp640', numba.int64),

    ('error_cnt', numba.int32),

    ('col', numba.uint8),
    ('row', numba.uint16),
    ('le', numba.uint8),
    ('te', numba.uint8),
    ('noise', numba.uint8),

    ('meta_idx', numba.uint32),
    ('raw_idx', numba.uint32)
]

"""
Functions to identify and interpret words generated by the LF-Monopix2 read-out.
    1. Pixel address and ToT (32-bit Word):
        [4-bit Monopix ID "0000"]+[1-bit identifier "0"]+[6-bit Column]+[6-bit Leading Edge TS]+[6-bit Trailing Edge TS]+[9-bit Row]
    2. Token Timestamp [40 MHz] Part 1 (32-bit Word):
        [4-bit Monopix ID "0000"]+[3-bit identifier "100"]+[23-bit Token Timestamp Part 1]+[1-bit Inj High Flag]+[1-bit Noise]
    3. Token Timestamp [40 MHz] Part 2 (32-bit Word):
        [4-bit Monopix ID "0000"]+[3-bit identifier "101"]+[25-bit Token Timestamp Part 2]
"""
@numba.njit
def is_monopix_data_1(word):
    return ((word & 0xF8000000) == 0x00000000)
@numba.njit
def is_monopix_data_2(word):
    return ((word & 0xFE000000) == 0x08000000)
@numba.njit
def is_monopix_data_3(word):
    return ((word & 0xFE000000) == 0x0A000000)
@numba.njit
def get_col(word):
    return (word >>21) & 0x3F
@numba.njit
def get_le(word):
    return (word >> 15) & 0x3F
@numba.njit
def get_te(word):
    return (word >> 9) & 0x3F
@numba.njit
def get_row(word):
    return (word) & 0x1FF
@numba.njit
def get_tot(word):
    return ( ((word >> 9) & 0x3F)-((word >> 15) & 0x3F) ) & 0x3F
@numba.njit
def get_noise_flag(word):
    return (word) & 0x3
@numba.njit
def get_token_TS_right(word):
    return (word) & 0x1FFFFFC
@numba.njit
def get_token_TS_left(word):
    return (word) & 0x1FFFFFF

"""
Functions to identify timestamps in 640 MHz (32-bit Words):
    1. Part: [4-bit Timestamp ID "XXXX"]+[4-bit identifier "YY01"]+[24-bit Timestamp Part 1]
    2. Part: [4-bit Timestamp ID "XXXX"]+[4-bit identifier "YY10"]+[24-bit Timestamp Part 2]
    3. Part: [4-bit Timestamp ID "XXXX"]+[4-bit identifier "YY11"]+[24-bit Timestamp Part 3]

    For "XXXX":
    - RX1 input Timestamp ID: "0100"
    - Injection Timestamp ID: "0101"
    - Monitor Timestamp ID: "0110"
    - TLU Timestamp ID: "0111"

    For "YY":
    - Sampled signal leading edge: "00"
    - Sampled signal trailing Edge: "01"
"""
@numba.njit
def is_timestamp640_rx_1(word, te=False):
    if te == True:
        return ((word & 0xFF000000) == 0x45000000)
    else:
        return ((word & 0xFF000000) == 0x41000000)
@numba.njit
def is_timestamp640_rx_2(word, te=False):
    if te == True:
        return ((word & 0xFF000000) == 0x46000000)
    else:
        return ((word & 0xFF000000) == 0x42000000)
@numba.njit
def is_timestamp640_rx_3(word, te=False):
    if te == True:
        return ((word & 0xFF000000) == 0x47000000)
    else:
        return ((word & 0xFF000000) == 0x43000000)

@numba.njit
def is_timestamp640_inj_1(word, te=False):
    if te == True:
        return ((word & 0xFF000000) == 0x55000000)
    else:
        return ((word & 0xFF000000) == 0x51000000)
@numba.njit
def is_timestamp640_inj_2(word, te=False):
    if te == True:
        return ((word & 0xFF000000) == 0x56000000)
    else:
        return ((word & 0xFF000000) == 0x52000000)
@numba.njit
def is_timestamp640_inj_3(word, te=False):
    if te == True:
        return ((word & 0xFF000000) == 0x57000000)
    else:
        return ((word & 0xFF000000) == 0x53000000)

@numba.njit
def is_timestamp640_mon_1(word, te=False):
    if te == True:
        return ((word & 0xFF000000) == 0x65000000)
    else:
        return ((word & 0xFF000000) == 0x61000000)
@numba.njit
def is_timestamp640_mon_2(word, te=False):
    if te == True:
        return ((word & 0xFF000000) == 0x66000000)
    else:
        return ((word & 0xFF000000) == 0x62000000)
@numba.njit
def is_timestamp640_mon_3(word, te=False):
    if te == True:
        return ((word & 0xFF000000) == 0x67000000)
    else:
        return ((word & 0xFF000000) == 0x63000000)

@numba.njit
def is_timestamp640_tlu_1(word, te=False):
    if te == True:
        return ((word & 0xFF000000) == 0x75000000)
    else:
        return ((word & 0xFF000000) == 0x71000000)
@numba.njit
def is_timestamp640_tlu_2(word, te=False):
    if te == True:
        return ((word & 0xFF000000) == 0x76000000)
    else:
        return ((word & 0xFF000000) == 0x72000000)
@numba.njit
def is_timestamp640_tlu_3(word, te=False):
    if te == True:
        return ((word & 0xFF000000) == 0x77000000)
    else:
        return ((word & 0xFF000000) == 0x73000000)

@numba.njit
def get_timestamp640_24bits(word):
    return word & 0x0000000000FFFFFF
@numba.njit
def get_timestamp640_8bits(word):
    return word & 0x00000000000000FF
@numba.njit
def get_timestamp640_tot(word):
    return word & 0x0000000000FFFF00

"""
Functions to identify TLU words (32-bit Words):
    1. Part: [1-bit TLU ID "1"]+[1-bit word identifier "0"]+[30-bit TLU data Part 1]
    2. Part: [1-bit TLU ID "1"]+[2-bit word identifier "10"]+[29-bit TLU data Part 2]
    3. Part: [1-bit TLU ID "1"]+[2-bit word identifier "11"]+[29-bit TLU data Part 3]

    The content of TLU data will depend on the data format given to the TLU:
        - Format 1: Timestamp only. [58-bit zeroes "0"]+[31-bit timestamp]
        - Format 2: Timestamp + Trigger number/counter. [58-bit zeroes "0"]+[15-bit timestamp]+[16-bit trigger number/counter]
        - Format 3: Timestamp + Trigger number/counter in higher sampling. [58-bit timestamp]+[30-bit trigger number/counter]
        - Other:    Trigger number/counter only. [58-bit zeroes "0"]+[31-bit trigger number/counter]
"""
@numba.njit
def is_tlu(word):
    return ((word) & 0x80000000 == 0x80000000)
@numba.njit
def get_tlu_number(word):
    return word & 0xFFFF
@numba.njit
def get_tlu_timestamp(word):
    return word & 0x7FFF0000


class Interpreter(object):
    def __init(self):
        self.reset()

    def interpret_data(self, raw_data, meta_data=None, chunk_size=1000000):
        hit_dtype = [('col', '<u1'), ('row', '<u2'), ('le', '<u1'), ('te', '<u1'), ('cnt', '<u8'), ('timestamp', '<u8'), ('scan_param_id', '<u4')]

        pbar = tqdm(total=len(raw_data))
        start = 0
        data_interpreter = RawDataInterpreter()
        if len(raw_data)==0:
            hit_data=np.array([], dtype=hit_dtype)
        while start < len(raw_data):
            tmpend = start + chunk_size

            hit_buffer = np.zeros(shape=chunk_size, dtype=hit_dtype)

            hit_data = data_interpreter.interpret(raw_data[start:tmpend], meta_data, hit_buffer)

            start = tmpend
            pbar.update(chunk_size)
        pbar.close()

        return hit_data, data_interpreter.get_error_count()

@numba.experimental.jitclass(class_spec)
class RawDataInterpreter(object):
    def __init__(self):
        self.reset()
        self.error_cnt = 0
        self.raw_idx = 0
        self.meta_idx = 0

    def reset(self):
        """ 
        Reset all values that are computed from multiple data words
        """
        # Data from the chip
        self.monopix_data_flag = 0
        self.monopix_token_timestamp = 0

        # Timestamp from RX1 sampled in FPGA
        self.rx_timestamp640_flag = 0
        self.rx_timestamp640 = 0

        # Timestamp from INJ sampled in FPGA
        self.inj_timestamp640_flag = 0
        self.inj_timestamp640 = 0

        # Timestamp from MONITOR/HITOR sampled in FPGA
        self.mon_timestamp640_flag = 0
        self.mon_timestamp640 = 0
        self.mon_tot640 = 0

        # Timestamp from TLU sampled in FPGA
        self.tlu_timestamp640_flag = 0
        self.tlu_timestamp640 = 0

    def get_error_count(self):
        return self.error_cnt

    def interpret(self, raw_data, meta_data, hit_data):
        """ 
        This function interprets data recorded by the LF-Monopix2 data acquisition system (LF2 + GPAC + MIO3 cards).

        The raw data words contain at least the LF-Monopix2 hit information and token timestamps (in 40 MHz), but they can also correspond to several timestamps 
        sampled in the MIO3 FPGA with a 640 MHz clock (e.g. From an external signal -RX1-, Injection, Monitor/Hit-or or TLU.) 
        and further data from a Trigger Logic Unit (TLU words).

        These flags store information about which words have been processed.
        monopix_data_flag:
            Monopix data spread across three consecutive data words.
        rx_timestamp640_flag:
            Signal from the RX1 LEMO in the MIO3 board sampled with a 640 MHz clock at the FPGA.
        inj_timestamp640_flag:
            Injection signal sampled with a 640 MHz clock at the FPGA.
        mon_timestamp640_flag:
            Monitor (Hit-Or) signal sampled with a 640 MHz clock at the FPGA.
        tlu_timestamp640_flag:
            TLU signal sampled with a 640 MHz clock at the FPGA.

        For additional info about data structure check corresponding modules in the Monopix firmware folder or basil software package.
        
        Parameters:
        -----------
        raw_data : np.array
            Array with raw data words.
        meta_data : np.array
            Array with meta information (scan_param_id, data length, ...)
        hit_data : 
            Array prepared to be filled with interpreted data.
            np.recarray(dtype=[('col', '<u1'), ('row', '<u2'), ('le', '<u1'), ('te', '<u1'), 
                            ('cnt', '<u8'), ('timestamp', '<u8'), ('scan_param_id', '<u4')])
        """

        hit_index = 0

        for raw_data_word in raw_data:

            ################
            # MONOPIX DATA #
            ################

            if is_monopix_data_1(raw_data_word):
                if self.monopix_data_flag != 0:
                    self.reset()
                    self.error_cnt += 1
                    continue

                # Asssign pixel data
                self.col = get_col(raw_data_word)
                self.row = get_row(raw_data_word)
                self.te = get_te(raw_data_word)
                self.le = get_le(raw_data_word)

                self.monopix_data_flag = 1

            elif is_monopix_data_2(raw_data_word):
                if self.monopix_data_flag != 1:
                    self.reset()
                    self.error_cnt += 1
                    continue
                
                # Get noise
                self.noise = get_noise_flag(raw_data_word)
                # Get right-most side of the token timestamp, shift it and add "0" on the right to turn it into a 640 MHz-like timestamp.
                self.monopix_token_timestamp = self.monopix_token_timestamp | ( (get_token_TS_right(raw_data_word) << 2) & 0x7FFFFF0 )
                
                self.monopix_data_flag = 2

            elif is_monopix_data_3(raw_data_word):
                if self.monopix_data_flag != 2:
                    self.reset()
                    self.error_cnt += 1
                    continue

                # Get left-most side of the token timestamp, shift it and merge it with the right-most one.
                self.monopix_token_timestamp = self.monopix_token_timestamp | ( (get_token_TS_left(raw_data_word) << 27) & 0xFFFFFF8000000 )
                
                # Fill the information for the 
                hit_data[hit_index]["row"] = self.row
                hit_data[hit_index]["col"] = self.col
                hit_data[hit_index]["le"] = self.le
                hit_data[hit_index]["te"] = self.te
                hit_data[hit_index]["cnt"] = self.noise
                hit_data[hit_index]["timestamp"] = self.monopix_token_timestamp
                hit_data[hit_index]["scan_param_id"] = self.raw_idx
                
                # Prepare for next hit: Increase hit index and reset monopix_data_flag
                hit_index += 1
                self.monopix_data_flag = 0

            ########################################
            # TIMESTAMP 640 MHz (RX1), TAG: 0xFA   #
            ########################################

            # Third word comes first in data

            elif is_timestamp640_rx_3(raw_data_word):
                if self.rx_timestamp640_flag != 0:
                    self.reset()
                    self.error_cnt += 1
                    continue

                self.rx_timestamp640 = self.rx_timestamp640 | ( (get_timestamp640_8bits(raw_data_word) <<48) & 0xFF000000000000 )
                
                self.rx_timestamp640_flag = 1

            elif is_timestamp640_rx_2(raw_data_word):
                if self.rx_timestamp640_flag != 1:
                    self.reset()
                    self.error_cnt += 1
                    continue

                self.rx_timestamp640 = self.rx_timestamp640 | ( (get_timestamp640_24bits(raw_data_word) <<24) & 0x00FFFFFF000000 )

                self.rx_timestamp640_flag = 2

            elif is_timestamp640_rx_1(raw_data_word):
                if self.rx_timestamp640_flag != 2:
                    self.reset()
                    self.error_cnt += 1
                    continue

                self.rx_timestamp640 = self.rx_timestamp640 | ( (get_timestamp640_24bits(raw_data_word) ) & 0x00000000FFFFFF )

                hit_data[hit_index]["col"] = 0xFA
                hit_data[hit_index]["row"] = 0
                hit_data[hit_index]["le"] = 0
                hit_data[hit_index]["te"] = 0
                hit_data[hit_index]["cnt"] = 0
                hit_data[hit_index]["timestamp"] = self.rx_timestamp640
                hit_data[hit_index]["scan_param_id"] = self.raw_idx

                # Prepare for next data block. Increase hit index and reset rx_timestamp640 flag.
                hit_index += 1
                self.rx_timestamp640_flag = 0

            ########################################
            # TIMESTAMP 640 MHz (INJ), TAG: 0xFC   #
            ########################################

            # Third word comes first in data

            elif is_timestamp640_inj_3(raw_data_word):
                if self.inj_timestamp640_flag != 0:
                    self.reset()
                    self.error_cnt += 1
                    continue

                self.inj_timestamp640 = self.inj_timestamp640 | ( (get_timestamp640_8bits(raw_data_word) <<48) & 0xFF000000000000 )
                
                self.inj_timestamp640_flag = 1

            elif is_timestamp640_inj_2(raw_data_word):
                if self.inj_timestamp640_flag != 1:
                    self.reset()
                    self.error_cnt += 1
                    continue

                self.inj_timestamp640 = self.inj_timestamp640 | ( (get_timestamp640_24bits(raw_data_word) <<24) & 0x00FFFFFF000000 )

                self.inj_timestamp640_flag = 2

            elif is_timestamp640_inj_1(raw_data_word):
                if self.inj_timestamp640_flag != 2:
                    self.reset()
                    self.error_cnt += 1
                    continue

                self.inj_timestamp640 = self.inj_timestamp640 | ( (get_timestamp640_24bits(raw_data_word) ) & 0x00000000FFFFFF )

                hit_data[hit_index]["col"] = 0xFC
                hit_data[hit_index]["row"] = 0
                hit_data[hit_index]["le"] = 0
                hit_data[hit_index]["te"] = 0
                hit_data[hit_index]["cnt"] = 0
                hit_data[hit_index]["timestamp"] = self.inj_timestamp640
                hit_data[hit_index]["scan_param_id"] = self.raw_idx

                # Prepare for next data block. Increase hit index and reset inj_timestamp640 flag.
                hit_index += 1
                self.inj_timestamp640_flag = 0

            ############################################
            # TIMESTAMP 640 MHz (MON/HITOR), TAG: 0xFD #
            ############################################

            # Third word comes first in data 

            # Get Timestamp of the Monitor Leading Edge.

            elif is_timestamp640_mon_3(raw_data_word):
                if self.mon_timestamp640_flag != 0:
                    self.reset()
                    self.error_cnt += 1
                    continue

                self.mon_timestamp640 = self.mon_timestamp640 | ( (get_timestamp640_8bits(raw_data_word) <<48) & 0xFF000000000000 )
                self.mon_tot640 = ( get_timestamp640_tot(raw_data_word) ) >> 8

                self.mon_timestamp640_flag = 1

            elif is_timestamp640_mon_2(raw_data_word):
                if self.mon_timestamp640_flag != 1:
                    self.reset()
                    self.error_cnt += 1
                    continue

                self.mon_timestamp640 = self.mon_timestamp640 | ( (get_timestamp640_24bits(raw_data_word) <<24) & 0x00FFFFFF000000 )

                self.mon_timestamp640_flag = 2

            elif is_timestamp640_mon_1(raw_data_word):
                if self.mon_timestamp640_flag != 2:
                    self.reset()
                    self.error_cnt += 1
                    continue

                self.mon_timestamp640 = self.mon_timestamp640 | ( (get_timestamp640_24bits(raw_data_word) ) & 0x00000000FFFFFF )

                hit_data[hit_index]["col"] = 0xFD
                hit_data[hit_index]["row"] = 0
                hit_data[hit_index]["le"] = 0
                hit_data[hit_index]["te"] = 0
                hit_data[hit_index]["cnt"] = self.mon_tot640
                hit_data[hit_index]["timestamp"] = self.mon_timestamp640
                hit_data[hit_index]["scan_param_id"] = self.raw_idx

                # Prepare for next data block. Increase hit index and reset mon_timestamp640 flag.
                hit_index += 1
                self.mon_timestamp640_flag = 0
            
            # Get Timestamp of the Monitor Trailing Edge.

            elif is_timestamp640_mon_3(raw_data_word, te=True):
                if self.mon_timestamp640_flag != 0:
                    self.reset()
                    self.error_cnt += 1
                    continue

                self.mon_timestamp640 = self.mon_timestamp640 | ( (get_timestamp640_8bits(raw_data_word) <<48) & 0xFF000000000000 )
                self.mon_tot640 = ( get_timestamp640_tot(raw_data_word) ) >> 8

                self.mon_timestamp640_flag = 1

            elif is_timestamp640_mon_2(raw_data_word, te=True):
                if self.mon_timestamp640_flag != 1:
                    self.reset()
                    self.error_cnt += 1
                    continue

                self.mon_timestamp640 = self.mon_timestamp640 | ( (get_timestamp640_24bits(raw_data_word) <<24) & 0x00FFFFFF000000 )

                self.mon_timestamp640_flag = 2

            elif is_timestamp640_mon_1(raw_data_word, te=True):
                if self.mon_timestamp640_flag != 2:
                    self.reset()
                    self.error_cnt += 1
                    continue

                self.mon_timestamp640 = self.mon_timestamp640 | ( (get_timestamp640_24bits(raw_data_word) ) & 0x00000000FFFFFF )

                hit_data[hit_index]["col"] = 0xFD
                hit_data[hit_index]["row"] = 1
                hit_data[hit_index]["le"] = 0
                hit_data[hit_index]["te"] = 0
                hit_data[hit_index]["cnt"] = self.mon_tot640
                hit_data[hit_index]["timestamp"] = self.mon_timestamp640
                hit_data[hit_index]["scan_param_id"] = self.raw_idx

                # Prepare for next data block. Increase hit index and reset mon_timestamp640 flag.
                hit_index += 1
                self.mon_timestamp640_flag = 0

            ########################################
            # TIMESTAMP 640 MHz (TLU), TAG: 0xFB   #
            ########################################

            # Third word comes first in data

            elif is_timestamp640_inj_3(raw_data_word):
                if self.tlu_timestamp640_flag != 0:
                    self.reset()
                    self.error_cnt += 1
                    continue

                self.tlu_timestamp640 = self.tlu_timestamp640 | ( (get_timestamp640_8bits(raw_data_word) <<48) & 0xFF000000000000 )
                
                self.tlu_timestamp640_flag = 1

            elif is_timestamp640_inj_2(raw_data_word):
                if self.tlu_timestamp640_flag != 1:
                    self.reset()
                    self.error_cnt += 1
                    continue

                self.tlu_timestamp640 = self.tlu_timestamp640 | ( (get_timestamp640_24bits(raw_data_word) <<24) & 0x00FFFFFF000000 )

                self.tlu_timestamp640_flag = 2

            elif is_timestamp640_inj_1(raw_data_word):
                if self.tlu_timestamp640_flag != 2:
                    self.reset()
                    self.error_cnt += 1
                    continue

                self.tlu_timestamp640 = self.tlu_timestamp640 | ( (get_timestamp640_24bits(raw_data_word) ) & 0x00000000FFFFFF )

                hit_data[hit_index]["col"] = 0xFB
                hit_data[hit_index]["row"] = 0
                hit_data[hit_index]["le"] = 0
                hit_data[hit_index]["te"] = 0
                hit_data[hit_index]["cnt"] = 0
                hit_data[hit_index]["timestamp"] = self.tlu_timestamp640
                hit_data[hit_index]["scan_param_id"] = self.raw_idx

                # Prepare for next data block. Increase hit index and reset tlu_timestamp640 flag.
                hit_index += 1
                self.tlu_timestamp640_flag = 0

            ############
            # TLU DATA #
            ############

            elif is_tlu(raw_data_word):
                tlu_word = get_tlu_number(raw_data_word)
                # Get the TLU timestamp, shift it and leave a 4-bit "0" on the right to turn it into a 640 MHz-like timestamp.
                tlu_timestamp_low_res = get_tlu_timestamp(raw_data_word) >> 12

                hit_data[hit_index]["col"] = 0xFF
                hit_data[hit_index]["row"] = 0
                hit_data[hit_index]["le"] = 0
                hit_data[hit_index]["te"] = 0
                hit_data[hit_index]["cnt"] = tlu_word
                hit_data[hit_index]["timestamp"] = tlu_timestamp_low_res
                hit_data[hit_index]["scan_param_id"] = self.raw_idx

                # Prepare for next data block. Increase hit index
                hit_index += 1
            
            # Increase raw_index and move to next data word.
            self.raw_idx += 1

        # Trim hit_data buffer to interpreted data hits
        hit_data = hit_data[:hit_index]

        # Find correct scan_param_id in meta data and attach to hit.
        if meta_data is not None:
            for scan_idx, param_id in enumerate(hit_data["scan_param_id"]):
                while self.meta_idx < len(meta_data):
                    if param_id >= meta_data[self.meta_idx]['index_start'] and param_id < meta_data[self.meta_idx]['index_stop']:
                        hit_data[scan_idx]['scan_param_id'] = meta_data[self.meta_idx]['scan_param_id']
                        break
                    elif param_id >= meta_data[self.meta_idx]['index_stop']:
                        self.meta_idx += 1
        else:
            pass
        return hit_data